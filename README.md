-------------------------------------------------------------------------------------------------------------------------------------------


## Lombok 어노테이션 정리


#### @ToString 

toString 메소드를 자동으로 생성해주는 어노테이션이다


        (System.out.println(">>>" + user.toString()); 가능하게 해줌)



#### @Getter 


해당 클래스의 필드값들의 getter메소드를 자동으로 만들어주는 어노테이션이다. (데이터의 캡슐화 이유로 필수) 

#### @Setter 

해당 클래스의 필드값들의 setter메소드를 자동으로 만들어주는 어노테이션이다. (데이터의 캡슐화 이유로 필수) 

#### @NoArgsConstructor 

아무값도 존재하지 않는 생성자를 만들수 있게 만드는 어노테이션이다. (기본 생성자를 만들어줌) 

 ex) 
      
        User user = new User();



#### @AllArgsConstructor 

전체의 값을 넣는 생성자를 만들수 있게 만드는 어노테이션이다. (여기에 필드에 쓴 모든생성자만 만들어줌) 

 ex) 
      
        User user1 = new User("martin", "martin@nate.com", LocalDateTime.now(), LocalDateTime.now());

#### @RequiredArgsConstructor

초기화 되지않은 final 필드나, @NonNull 이 붙은 필드에 대해 생성자를 생성해 줍니다. @NonNull을 필드값위에 붙인다

 ex) 
           @NonNull
           private String name;
           @NonNull
           private String email;
           
#### @Data 

@ToString, @Getter, @Setter, @RequiredArgsConstructor, @EqualsAndHashCode 를 합쳐놓은 기능이다

#### @Builder 

빌더 기능을 사용 가능하게 하는 어노테이션이다.

 ex) 

        User user3 = User.builder().name("martin").email("martin@nate.com").build();
        

        
 #### @Transactional
  
데이터베이스를 다룰 때 트랜잭션을 적용하면 데이터 추가, 갱신, 삭제 등으로 이루어진 작업을 처리하던 중 오류가 발생했을 때 모든 작업들을 원상태로 되돌릴 수 있다. 모든 작업들이 성공해야만 최종적으로 데이터베이스에 반영하도록 한다. 일련의 작업들을 묶어서 하나의 단위로 처리하고 싶다면 @Transactional을 쓰자

-------------------------------------------------------------------------------------------------------------------------------------------


## 인티티 설계시 주의점



### 엔티티에는 가급적 Setter를 사용하지 말자

- Setter가 모두 열려있으면 변경포인트가 너무 많아서, 유지보수가 어렵다.


### 모든 연관관계는 지연로딩으로 설정!

- 즉시로딩('EAGER')은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. 특히 JPQL을 실행할 때 N+1 문제가 자주 발생한다.
- 실무에서 모든 연관관계는 지연로딩('LAZY')으로 설정해야 한다.
- 연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join 또는 엔티티 그래프 기능을 사용한다.
- @XToOne(OneToOne, ManyToOne)관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야한다.


### 컬렉션은 필드에서 초기화 하자.

- 컬렉션은 필드에서 바로 초기화 하는 것이 안전하다.
- null 문제에서 안전하다.

ex)
        
![image](https://github.com/Parkcharito/studySpringBootJPA/assets/100402443/26292a4a-04cb-4c75-962a-5bb056ea33e5)


-------------------------------------------------------------------------------------------------------------------------------------------


# 데이터베이스

### 데이터 마트의 정의

데이터 마트는 단일 주제 또는 LOB에 초점을 맞춘 단순한 형태의 데이터 웨어하우스입니다. 귀사의 팀은 데이터 마트를 사용해 데이터에 빠르게 액세스하고, 인사이트를 신속하게 얻을 수 있습니다. 복잡한 데이터 웨어하우스 또는 다양한 소스로부터 수동으로 집계된 데이터 내에서 원하는 데이터를 탐색하느라 시간을 낭비할 필요가 없기 때문이죠.


### 데이터 마트를 만드는 이유

데이터 마트는 기업 내 특정 팀 또는 LOB가 요청한 데이터에 대한 보다 손쉬운 액세스를 제공합니다. 예를 들어 마케팅 팀이 휴가 시즌 캠페인의 성과 개선에 도움이 될 데이터를 찾고 있다면, 여러 시스템에 흩어져 있는 데이터를 솎아내고 결합하는 작업이 시간, 정확도, 무엇보다도 비용 측면에서 더 큰 이익을 안겨줄 것입니다.

여러 소스에 흩어진 데이터 위치를 파악하는 일을 하는 팀의 경우, 데이터를 공유하고 협업하는 일에 스프레드시트를 주로 활용할 것입니다. 이와 같은 작업은 보통 인적 오류, 혼란, 복잡한 조정, 여러 개의 소스 저장소 등의 문제를 유발해 소위 말하는 '스프레드시트 악몽'을 초래하죠. 데이터 마트는 필요한 데이터가 보고서, 대시보드 및 시각화 자료로 생성되기 전에 수집 및 정리되는 중앙화된 공간으로 널리 활용되고 있습니다.



